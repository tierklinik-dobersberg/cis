package wiki

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/tierklinik-dobersberg/cis/pkg/httperr"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.opentelemetry.io/otel"
)

type (
	// Collection is a list of documents that are somehow related to each other
	// by their content. Collections are user-defined and allow for better grouping
	// and organizing of documents.
	Collection struct {
		// Name is the unique name of the collection.
		Name string `json:"name" bson:"name"`

		// ImageUrl holds the URL to the collection image. The URL might
		// also be a data-url that contains the image itself (recommended).
		ImageURL string `json:"imageUrl" bson:"imageUrl"`

		// Description may hold an additional description of the collection.
		Description string `json:"description" bson:"description,omitempty"`
	}

	// Document represents a single document at a given path in a collection.
	// The combination of collection name and document path must be unique.
	Document struct {
		// Path holds the path to the document.
		// Paths are built like file-system paths and are used
		// to model a directory-like structure of wiki pages.
		Path string `json:"path" bson:"path"`

		// Collection holds the name of the collection the document
		// is part of.
		Collection string `json:"collection" bson:"collection"`

		// Title holds the title of the document.
		Title string `json:"title" bson:"title"`

		// Description may hold the document description as displayed
		// in overview lists.
		Description string `json:"description" bson:"description,omitempty"`

		// Metadata holds additional metadata about the content of the documennt.
		Metadata Metadata `json:"metadata" bson:"metadata"`

		// Content holds the actual user content of the document.
		Content string `json:"content" bson:"content"`
	}

	Metadata struct {
		// CreatedAt holds the time at which the document has been  created.
		CreatedAt time.Time `json:"createdAt" bson:"createdAt"`

		// CreatedBy holds the name of the user that created the document.
		CreatedBy string `json:"createdBy" bson:"createdBy"`

		// UpdatedAt holds the time at which the document has been last updated.
		UpdatedAt time.Time `json:"updatedAt" bson:"updatedAt"`

		// UpdatedBy holds the name of the user that last updated the document.
		UpdatedBy string `json:"updatedBy" bson:"updatedBy"`

		// Tags may hold a list of user-defined tags assigned to the document.
		Tags []string `json:"tags" bson:"tags"`

		// Owner is the name of the user that acts as the document owner.
		// This defaults to the user that created the document by may be changed
		// by an administrator.
		Owner string `json:"owner" bson:"owner"`

		// Content holds content metadata.
		Content ContentMetadata `json:"content" bson:"content"`
	}

	// Reference is a reference to another document in either same or another
	// collection.
	Reference struct {
		// Collection holds the name of the target collection.
		Collection string `json:"collection" bson:"collection"`

		// Path holds the path of the document in the target collection.
		Path string `json:"path" bson:"path"`
	}

	// Backlink is a backlinkg to a document and returned by FindBacklinks.
	Backlink struct {
		Reference `bson:",inline"`

		Title string `json:"title" bson:"title"`
	}

	// ContentMetadata holds metadata about the content of a document and is auto-
	// generated by parsing and analyzing the content.
	ContentMetadata struct {
		// LinkedDocuments holds a list of paths to other documents that are linked in the
		// parent document.
		References []Reference `json:"references" bson:"references"`
	}

	// Database stores wiki documents and supports common operations on documents.
	Database struct {
		documents   *mongo.Collection
		collections *mongo.Collection
	}

	// UpdateOperation is specified when updating documents.
	UpdateOperation func(set bson.M) error
)

// Names of MongoDB collections used by this package.
const (
	CollectionColName = "wiki:collections"
	DocumentColName   = "wiki:documents"
)

// WithUpdateContent specifies the new document content for an update operation.
func WithUpdateContent(collection, content string) UpdateOperation {
	return func(set bson.M) error {
		var contentMd ContentMetadata
		if err := AnalyzeContent(collection, content, &contentMd); err != nil {
			return fmt.Errorf("failed to analyze content: %w", err)
		}

		set["content"] = content
		set["metadata.content"] = contentMd

		return nil
	}
}

// WithUpdateCollection changes the parent collection during an update operation.
func WithUpdateCollection(collection string) UpdateOperation {
	return func(set bson.M) error {
		set["collection"] = collection

		return nil
	}
}

// WithUpdateOwner changes document ownership during an update operation.
func WithUpdateOwner(owner string) UpdateOperation {
	return func(set bson.M) error {
		set["metadata.owner"] = owner

		return nil
	}
}

// WithUpdateTags changes replaces document tags with a new set during
// an update operation.
func WithUpdateTags(tags []string) UpdateOperation {
	return func(set bson.M) error {
		set["metadata.tags"] = tags

		return nil
	}
}

// WithUpdateTitle changes the document title during an update operation.
func WithUpdateTitle(title string) UpdateOperation {
	return func(set bson.M) error {
		set["title"] = title

		return nil
	}
}

// WithUpdateDescription changes the document description during an update
// operation.
func WithUpdateDescription(desc string) UpdateOperation {
	return func(set bson.M) error {
		set["description"] = desc

		return nil
	}
}

// WithUpdatePath changes the document path during an update operation.
func WithUpdatePath(path string) UpdateOperation {
	return func(set bson.M) error {
		if err := ValidateDocumentPath(path); err != nil {
			return err
		}

		set["path"] = path

		return nil
	}
}

// NewDatabase returns a new document and collections database
// using the provided MongoDB database.
func NewDatabase(ctx context.Context, mongoDB *mongo.Database) (*Database, error) {
	db := &Database{
		documents:   mongoDB.Collection(DocumentColName),
		collections: mongoDB.Collection(CollectionColName),
	}

	if err := db.setup(ctx); err != nil {
		return nil, fmt.Errorf("setup: %w", err)
	}

	return db, nil
}

func (db *Database) setup(ctx context.Context) error {
	if _, err := db.collections.Indexes().CreateMany(ctx, []mongo.IndexModel{
		{
			Keys: bson.M{
				"name": 1,
			},
			Options: options.Index().SetUnique(true),
		},
	}); err != nil {
		return fmt.Errorf("creating indexes: %w", err)
	}

	if _, err := db.documents.Indexes().CreateMany(ctx, []mongo.IndexModel{
		{
			Keys: bson.D{
				{Key: "collection", Value: 1},
				{Key: "path", Value: 1},
			},
			Options: options.Index().SetUnique(true),
		},
		{
			Keys: bson.D{
				{Key: "title", Value: "text"},
				{Key: "description", Value: "text"},
				{Key: "content", Value: "text"},
				{Key: "tags", Value: "text"},
			},
		},
	}); err != nil {
		return fmt.Errorf("creating indexes: %w", err)
	}

	return nil
}

// CreateCollection creates a new document collection with the given name. It is not possible to change the name
// of a collection after it has been created.
func (db *Database) CreateCollection(ctx context.Context, name string, description string, imageURL string) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.CreateCollection")
	defer sp.End()

	col := Collection{
		Name:        name,
		ImageURL:    imageURL,
		Description: description,
	}

	if err := ValidateCollection(col); err != nil {
		return err
	}

	if _, err := db.collections.InsertOne(ctx, col); err != nil {
		return err
	}

	EventCollectionCreated.Fire(ctx, col)

	return nil
}

func (db *Database) UpdateCollection(ctx context.Context, name string, description string, imageURL string) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.UpdateCollection")
	defer sp.End()

	col := Collection{
		Name:        name,
		ImageURL:    imageURL,
		Description: description,
	}

	if err := ValidateCollection(col); err != nil {
		return err
	}

	res, err := db.collections.ReplaceOne(ctx, bson.M{"name": name}, col)
	if err != nil {
		return err
	}

	if res.MatchedCount != 1 {
		return httperr.NotFound("collection", name)
	}

	EventCollectionCreated.Fire(ctx, col)

	return nil
}

// DeleteCollection deletes a document collection and moves all documents of the collection to migrateTargetCollection.
// If migrateTargetCollection is an empty string the documents are not moved and will become orphan.
func (db *Database) DeleteCollection(ctx context.Context, name string, migrateTargetCollection string) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.DeleteCollection")
	defer sp.End()

	if migrateTargetCollection != "" {
		_, err := db.documents.UpdateMany(
			ctx,
			bson.M{
				"collection": name,
			},
			bson.M{
				"$set": bson.M{
					"collection": migrateTargetCollection,
				},
			},
		)
		if err != nil {
			return fmt.Errorf("migrate documents to new collection: %w", err)
		}
	}

	res, err := db.collections.DeleteOne(ctx, bson.M{"name": name})
	if err != nil {
		return fmt.Errorf("deleting collection: %w", err)
	}

	if res.DeletedCount != 0 {
		return httperr.NotFound("collection", name)
	}

	EventCollectionDeleted.Fire(ctx, map[string]interface{}{
		"collection": name,
	})

	return nil
}

func (db *Database) GetCollection(ctx context.Context, name string) (*Collection, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.GetCollection")
	defer sp.End()

	res := db.collections.FindOne(ctx, bson.M{
		"name": name,
	})
	if res.Err() != nil {
		if errors.Is(res.Err(), mongo.ErrNoDocuments) {
			return nil, httperr.NotFound("collection", name)
		}

		return nil, res.Err()
	}

	var col Collection
	if err := res.Decode(&col); err != nil {
		return nil, err
	}

	return &col, nil
}

// ListCollections lists all collections stored in the database.
func (db *Database) ListCollections(ctx context.Context) ([]*Collection, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.ListCollections")
	defer sp.End()

	res, err := db.collections.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("finding collections: %w", err)
	}

	var result []*Collection

	if err := res.All(ctx, &result); err != nil {
		return nil, fmt.Errorf("retrieving collections: %w", err)
	}

	return result, nil
}

func (db *Database) SearchDocuments(ctx context.Context, searchTerm string) ([]Document, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.SearchDocuments")
	defer sp.End()

	filter := bson.M{
		"$text": bson.M{
			"$search":   searchTerm,
			"$language": "de",
		},
	}

	res, err := db.documents.Find(
		ctx,
		filter,
		options.Find().SetProjection(bson.M{
			"path":        1,
			"collection":  1,
			"description": 1,
			"metadata":    1,
			"title":       1,
		}),
	)

	if err != nil {
		return nil, fmt.Errorf("find: %w", err)
	}

	var documents []Document
	if err := res.All(ctx, &documents); err != nil {
		return nil, fmt.Errorf("decoding documents: %w", err)
	}

	return documents, nil
}

func (db *Database) FindRecentlyUpdated(ctx context.Context, limit int) ([]Document, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.FindRecentlyUpdated")
	defer sp.End()

	res, err := db.documents.Find(
		ctx,
		bson.M{},
		options.Find().
			SetProjection(bson.M{
				"path":        1,
				"collection":  1,
				"description": 1,
				"metadata":    1,
				"title":       1,
			}).
			SetSort(bson.M{
				"metadata.updatedAt": -1,
			}).
			SetLimit(int64(limit)),
	)
	if err != nil {
		return nil, fmt.Errorf("find: %w", err)
	}

	var documents []Document
	if err := res.All(ctx, &documents); err != nil {
		return nil, fmt.Errorf("decoding documents: %w", err)
	}

	return documents, nil
}

// LoadDocument loads the document stored in collection at path.
func (db *Database) LoadDocument(ctx context.Context, collection, path string) (*Document, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.LoadDocument")
	defer sp.End()

	res := db.documents.FindOne(ctx, bson.M{
		"collection": collection,
		"path":       path,
	})

	if res.Err() != nil {
		if errors.Is(res.Err(), mongo.ErrNoDocuments) {
			return nil, httperr.NotFound("document", fmt.Sprintf("%s:%s", collection, path))
		}

		return nil, res.Err()
	}

	var doc Document
	if err := res.Decode(&doc); err != nil {
		return nil, err
	}

	return &doc, nil
}

func (db *Database) FindBacklinks(ctx context.Context, collection, path string) ([]Backlink, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.FindBacklinks")
	defer sp.End()

	res, err := db.documents.Find(
		ctx,
		bson.M{
			"metadata.content.references": bson.M{
				"$elemMatch": bson.M{
					"collection": collection,
					"path":       path,
				},
			},
		},
		options.Find().SetProjection(bson.M{
			"path":       1,
			"collection": 1,
			"title":      1,
		}),
	)

	if err != nil {
		return nil, fmt.Errorf("find: %w", err)
	}

	var backlinks []Backlink
	if err := res.All(ctx, &backlinks); err != nil {
		return nil, fmt.Errorf("decoding documents: %w", err)
	}

	return backlinks, nil
}

// CreateDocument creates a new document doc.
func (db *Database) CreateDocument(ctx context.Context, doc Document) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.CreateDocument")
	defer sp.End()

	if err := ValidateDocument(doc); err != nil {
		return fmt.Errorf("validate: %w", err)
	}

	if _, err := db.documents.InsertOne(ctx, doc); err != nil {
		return fmt.Errorf("insert: %w", err)
	}

	// clear out the content before publishing it as an event.
	doc.Content = ""
	EventDocumentCreated.Fire(ctx, doc)

	return nil
}

// DeleteDocument deletes the document at documentPath in collection.
func (db *Database) DeleteDocument(ctx context.Context, collection, documentPath string) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.DeleteDocument")
	defer sp.End()

	if collection == "" {
		return errMissingCollectionName
	}
	if err := ValidateDocumentPath(documentPath); err != nil {
		return err
	}

	res, err := db.documents.DeleteOne(ctx, bson.M{
		"collection": collection,
		"path":       documentPath,
	})
	if err != nil {
		return err
	}

	if res.DeletedCount == 0 {
		return httperr.NotFound("document", fmt.Sprintf("%s:%s", collection, documentPath))
	}

	EventDocumentDeleted.Fire(ctx, map[string]string{
		"collection": collection,
		"path":       documentPath,
	})

	return nil
}

// UpdateDocument replaces the document stored ad documentPath in collection with doc. It may be used
// to move documents between collections or to change the path of the document as well.
func (db *Database) UpdateDocument(ctx context.Context, collection, documentPath, user string, ops ...UpdateOperation) error {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.UpdateDocument")
	defer sp.End()

	if collection == "" {
		return errMissingCollectionName
	}
	if err := ValidateDocumentPath(documentPath); err != nil {
		return err
	}

	set := bson.M{}

	for _, op := range ops {
		if err := op(set); err != nil {
			return err
		}
	}

	set["metadata.updatedBy"] = user
	set["metadata.updatedAt"] = time.Now()

	res, err := db.documents.UpdateOne(
		ctx,
		bson.M{
			"collection": collection,
			"path":       documentPath,
		},
		bson.M{
			"$set": set,
		},
	)
	if err != nil {
		return fmt.Errorf("replace: %w", err)
	}

	key := fmt.Sprintf("%s:%s", collection, documentPath)
	if res.MatchedCount != 1 {
		return httperr.NotFound("document", key)
	}

	EventDocumentUpdated.Fire(ctx, key)

	return nil
}

// ListDocuments lists all documents stored under directory in collection.
func (db *Database) ListDocuments(ctx context.Context, collection, directory string, recursive bool) ([]Document, error) {
	ctx, sp := otel.Tracer("").Start(ctx, "wiki.ListDocuments")
	defer sp.End()

	directory = strings.TrimSuffix(directory, "/")

	pathFilter := bson.M{
		"$regex": fmt.Sprintf("^%s($|\\/[^/]+$)", directory),
	}
	if recursive {
		pathFilter = bson.M{
			"$regex": fmt.Sprintf("^%s.*$", directory),
		}
	}

	iter, err := db.documents.Find(
		ctx,
		bson.M{
			"collection": collection,
			"path":       pathFilter,
		},
		options.Find().SetProjection(bson.M{
			"title":              1,
			"path":               1,
			"description":        1,
			"collection":         1,
			"metadata.owner":     1,
			"metadata.updatedAt": 1,
			"metadata.updatedBy": 1,
			"metadata.tags":      1,
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("query: %w", err)
	}

	var result []Document
	if err := iter.All(ctx, &result); err != nil {
		return nil, fmt.Errorf("retrieving documents: %w", err)
	}

	return result, nil
}
